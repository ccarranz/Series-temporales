# -*- coding: utf-8 -*-
"""PRACTICA SINCRONICO AST - Clase 6_ejercicio_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NLJ_UMlXmVP1aypwzl4Q8gHYEPWbRFVB

<div class="alert alert-block alert-info">
    <h1>Análisis de Series Temporales</h1>
    <h3>Clase 6 - Modelo LSTM</h3>
    <h3>Ejercicio 3_sincronico</h3>
        <p>Docente: Rodrigo Del Rosso<p>
        <p>Asistentes: Sebastián Calcagno, Drago Braian <p>
</div>

**Modelo LSTM**  

Las LSTM son un tipo especial de redes recurrentes. La característica principal de las redes recurrentes es que la información puede persistir introduciendo bucles en el diagrama de la red, por lo que, básicamente, pueden «recordar» estados previos y utilizar esta información para decidir cuál será el siguiente.  
Esta característica las hace muy adecuadas para manejar series cronológicas. Mientras las redes recurrentes estándar pueden modelar dependencias a corto plazo (es decir, relaciones cercanas en la serie cronológica), las LSTM pueden aprender dependencias largas, por lo que se podría decir que tienen una «memoria» a más largo plazo.  

http://colah.github.io/posts/2015-08-Understanding-LSTMs/

**Esquema simplificado de la estructura LSTM:**

![lstm_fig_4.PNG](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArQAAAE3CAYAAABb8tIxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADf+SURBVHhe7Z1rkBzVmab5u7/WRGzE7o9lJmY1E+uI2Y2w196I3Y0NMxN4kc3Y6AJGgI2HwRrbAo+xwSDQHSE1ujQNEhddQFJ3S90tdatpXUBIMkKIlkBosCQLgRk8UgBmGYzRajR4zDCYOFvfqfyqT2WfrKruzsqszHyeiDe68lpZpyvrPHXq5MmLDAAAAABAhkFoAQAAACDTILQAAAAAkGkQWgAAAADINAgtAAAAAGQahBYAAAAAMg1CCwAAAACZBqEFAAAAgEyD0AIAAABApkFoAQAAACDTILQAAAAAkGkQWgAAAADINAgtAAAAAGQahBYAAAAAMg1CCwAAAACZBqEFAAAAgEyD0AIAAABApkFoAQAAACDTILQAAAAAkGkQWigkb/XeahYeDibGylvbzfWXdphDwSQApMeEzmUAyA0ILeSUd0znzCvNFy6dUs7M7eatYIkuq1cJvnX4qLONw+GO0P4ACoqcC3qOLT0azEyS6nM58pwFgNyD0EIOOWoWXlqS2Zm3muuteJYrvet733GW32o6a9V8thXWL72Hlrr7Aigm0jL6BT2PxvCrhWwX3/njnMs1zlkAyD8ILeSMoGU23FrktqpOqIW1LMtUmlBobMus86XQymSdL4kB8oUwtvOHX0sAIAChhVxhW418FZxT8dl1RHhHVYYjsjq6X17Q6mt/Xq1uiSq3VJV/di23PAU/g/aWW4yqKn6AzOP5UjeqhdY5X6q+XMp8+eVk9LlU/cvH6OcYfZ4553LwuLx+8KU2WNcm9AWXcxYgfyC0kCPKlaWvIpIKrKrikorPtjKNVKi2krOC66yj80sVX2UbR4KlEtbpkZYnrVDLx0IXBcgT9j2vouimcl6U3/+j3vP2fAvWDf+CEhbYUItvrfNs9OMRyudu9RfQWvvinAXILggt5AZbeY2qKAVXdCMeuxWo29rkk159jiq5jXoOgBwRnCcLl1b/gmEl0XteVBMpiqEW3pEvlyUaOc9C2wtV+1A4ZwFyC0ILuSGqsoyubLVVJ9Si5Kwj245U3NXrucvsc+h+a1ToAFnG/6WxunW0+pxxqV7PSmiwr+r9ilyOnLMNnWehc84rsyU4ZwHyC0ILuWF0ZVuuQEdVdM46tlIL/QQq88rS6lbAwb5K644sK7fohPfhr/QBsk75HBj1pVFksNI6OnJeVJ8/gjMdtPRqi6h7ztjzr7SP8nRj59nIORvMr5LT0j56G98XAGQThBZyRNCyIxVVkHDl61Z8gq3Iqn6qrP7psbxc9iXzqitoXSbT7n7DzwGQD6rf/4qVQ0cGR86ZoN+5i5VfPZ+CeUJlfvmcdQWz/nnmnLPOfqoSCC7nLEB+QWgBAAAAINMgtAAAAACQaRBaAAAAAMg0CC0AAAAAZBqEFgAAAAAyDUILAAAAAJkGoQUAgJbhwIEDwSMAgMZBaAEAoCX4+OOPzaJFi4IpAIDGQWgBAKAlOH/+vGlvbw+mAAAaB6EFAICW4Ny5cwgtAIwLhBYAAFqCs2fPmg0bNgRTAACNg9ACAEBLgNACwHhBaKHwDA8PB48AIE1Onjxptm3bFkwBADQOQguF56GHHrIXowBAuhw/ftwMDg4GUwAAjYPQQuHp6uoyb775ZjAFAGlx5MgRs2fPnmAKAKBxEFooPENDQ+bUqVPBFACkhdxUgRsrAMB4QGih8EgFSj9agPTZv3+/OXToUDAFANA4CC0UHum3x8+cAOkj/WflfAQAGCsILRSed9991zzyyCPBFACkhfRnf/3114MpAIDGQWgBSqxYscLepQgA0oPzEADGC0ILUGL37t303QNIkY8//tgsWrQomAIAGBsILUCJv//7vzePPfZYMAUASSNdf2RMaACA8YDQApT49NNPzZIlS8yFCxeCOQCQJDJ0Xk9PTzAFADA2EFqAABmPljEwAdJBzj0ZtgsAYDwgtAABcjHK4sWLzYcffhjMAYCk2LZtG0N2AcC4QWgBHGQ82p07dwZTAJAUMnTe22+/HUwBAIwNhBbAQVpn29raGDoIIGHk15GPPvoomAIAGBsILUAI6cvX19cXTAFAs5GLMeWLJADAeEFoAUJ88skndoD3N954I5gDAM1EzjWGzQOAiYDQAniQvnzLli1jGC+ABJBfRaT/OgDAeEFoASI4cuSIWbdunR2jFgCah7TOvv7668EUAMDYQWgBaiB9aWk5Amgeestb+QsAMF4QWoAaSCXb0dFh72IEAPEj/WfllxAAgImA0ALU4f3337cXiR09ejSYAwBxsXfvXu4QBgATBqEFaAAZn3bVqlXm0KFDwRwAiAO5ocLZs2eDKQCA8YHQAjSISK38NEqfWmg2s2bNMhdddJHtw33mzBn7eNKkScHS/CA3UpD+szJUHgDAREBoAcaA9KmVK7J7enoY0gsaQmTUTSOMRWiHh4er9r98+fJgibHbyLxGkW1l/aRuLCJ90zds2BBMAQCMH4QWYIzIMF7S9UDubCRDezGsF/hQ0XRFVOZNnjw5mIqmUaH1LZP9y3yh1YV2586d5uDBg8EUAMD4QWgBxsm5c+ds65J0Q3j33XeDuQBlRCxFDkVio1Dh1CiNCq0sl2Wyfhjdp0ZFWvcXnq/P6UbFWF9LeP5EkX7pchMTAICJgtACTJDjx4/b1trNmzeb06dP02ILVdIYRbj1VB6H5bLRFtqo5eHn0PWVcIusr4VWZVYlVvbpe66xIl125LzhfAGAOEBoAWJALmo5efKkbbGVSlqGInrnnXeCpVA0akmooN0R3JZVlVjZtlGhFcJ9aN315LHMi0JbeLXfbVho9blVtAVdp1bLcyNIt53du3cHUwAAEwOhBYiZ8+fP23vTy8+pcgW33Jihq6vL9hcUCXjttddsFwXujJRfxiqhbsYqtC66DxVln9Dqvt3UE1pfJiq0cn7wpQ8A4gKhBWgy8tPqm2++absmPPPMM2ZgYMD2u5WWXImMmiCtVTIsGOQHlUmRwjAqtCqeYcYrtOH9hoVWW2RVWHV6LC20cSD9Zh966KFgCgBg4iC0ACkirbQiu9J6u2TJkko/XMblzD4qi66IiiCqHPpaT5VGhVYE1JVidzsh3P81LKy6vgqtHrNOC+F9xIH+WgEAEBcILUCLIBIrrbjSD3fZsmW2Ty5kG1/XApfwMpXdRoVWUDHWqKwK7vOHRVrnyV9XYN3lKrHh54g6lkaQ97m8v/lFAgDiBKEFaEHkJ1m5Jaj0vZU+uQB5QX6BkF8iAADiBKEFaFFkOCNpYZPWLPnL8EaQB7RbDQBAnCC0AC2OtNBKS610RWBkBMgy0s1AvqDRRxwA4gahBcgIe/bssSMiILWQVWQ4O8aeBYBmgNACZIj9+/fb8Tu5oAayxkcffWSHqZNbRgMAxA1CC5Axjhw5gtRC5pB+4IODg8EUAEC8ILQAGUSkVgamp/sBZAHpM7tixQpaZwGgaSC0ABlFBqeXu44BtDq0zgJAs0FoATKKDOO1Zs0ac/To0WAOQOtB31kASAKEFiDDXLhwwQ6DJDdiAGhFZHQOCQBAM0FoATLOq7943Sxpu890PX3MdAwcMXeu32duWrnDTF/Ya/78x48TklquuH2tmT13gbn8tvXe5WQkU+b32PNWzt+V24bN5v0nzIHjZ8w//vaj4EwHgFogtAAZ5Nw//c48+eLr5gernzSX39lpblnQYf560Voz5b79Zlr7c+bqB180Mx552Vy39pT55mOvEpJKbl/6iLm5fbt3GRmJnKdyvsp5K+fv1Pt+aqa0PW2mLR6y5/fNq540Q8OvmvfP/zb4BACAMAgtQIYYPvWmmdm+w3xldreZvvRJM/3+5831606ZG9e8ZO5ecK/59tqfeStMQpLOrI4d5if3rjLfeuy0dzlpLNevf6V0ng+bq9qeMl+9q9ue/08feyP4RAAABaEFyAAnfvmu/Tly2j2D5uoHX/BWfD9cscX8cHmXdxkhSebGR180dy1cam5ce8y7nIw/31h91ExbPGhuuG/QvPSLXwWfEACA0AK0ML985wNz26N7zZXzt9pWGl8Fp/n2uuO2lVZaa33LCUkiN6z/uZl9zwrzvVV7vMtJPJEvtlMWbDOzHtxtXn/7N8EnBkBxQWgBWpSufSfMFXdvNtNXHixVYI39bHvLyq3m1mWbvMsIaXake4H0m5VfC3zLSfyRPrdfm9tj1u3+2+CTA6CYILRgli9fbiZNmmQuuugic/HFF5tZs2aZDz74IFgKSfPxJ783izqfNVMW9ptr15z0VmJRkT60cxbcQ79FkkpEZEVoef8lG7mobOo9g3aEhN/9y78GnyQAxQKhLTgiryKy4YjkQvLI6AUzZcitpU+WKqrxScGdi+8333n4Oe8yQpqVW9q32a4GN6wb25cwEldOm2ltT5lvtg2Yfzj3YfCJAo2gDTqaM2fOBEsgSyC0Baavr69yAq9du9bOk5ZZkVmENnnOvvv/zFULe83VKw94KqvGIv1ob2tba1vJpOvBnfd2WMnwrUtIXJGWWRnRgFE20o90UZIxbU+dfS/4ZIEoRFy1DlRkngguZA+EtsDMmDHDnsjSSgvpIi2zIrMyDJevkqqXm9sH7AVh8+bNGxX61JJm5S/XvmxuW/qo+cmS1fZiMN86JPnIeLZXzuuhpbYO+gulNO5A9kFoC8zkyZPtyfzUU08FcyANpM+sdDOYSMus/Mw7e+F9XqH961X7vNsQMt58a/0pM+uBnfZLlFyISJ/Z1ou01F7fNkCf2hpo6yxdDPIBQltgvvjFLyK0LYBcAFbuM+uvmBrNXz08bObOm18ls3PnL6TljMQS6U7wnYcO2rGO5cJD6dbyV48c9q5LWiNTlj5lh/37/aefBp824KJCC/mA/2SB0RbaOXPmBHPGxvDwsN1e9gPjQ4bmktEMxnsBWDiz7h+sEtrblzzsXY8QjYxbPHP1M/bOXtIXVrsQSJ9YafWXiMDOXrTMSqxc/CVdDXz7Iq2W02bKokHz8M5jwScOuCC0+YL/ZIGRC8H0hHYvCpPHclGYdpj39S+SZSKyGhg7ctMEGWd2rENz1YtcFKZCK4LrW4cUM3LRoHRB+ZuVPeaOex+0XQZkVIwft60rzes1339gl22FvenhQ/YuXxLpXuDbF8lGZEivK+ZssXcbhGq0UUcaZ8Jo/edbBq0JQltgRF6120E47ti0kqgLxxDa8SM/BZZvmuCviMYbtz8tdw3Lf+oJp7Sm3ty+3Yrr3QuX2C888kVHpJW+r8XI9PsPmZntO4JPHlD0V0aJi9R9KrsSLhrLBghtwRGpFVn13VihVgutgtCOD2ktkdvZxtXVIBzpT8twXcXI9x980vZrDcup3HpWug1IK6yMdMHYxMXOlQv6zfCpN4NPIFC0nnMj82ihzR4ILUQSFlo92d0x+hDa8XGT3Dzh/mFvxRNXaJ0tRm69b4NtjZduA3IBoPzfpa+rdCmQ7gW0whKJDOU1Y3E/F4g1CEKbPRBaqIkrtD4Q2rEjrSTT7qFva5Ezc8PPzdyuI2bZloPmgZ6fmrW9e8z6vqfs47bNz5kFXcPmuxtOeLcNR7oRaJ/p2Yvb7bRc4IXIknCmLd5h9rz0RvBJBPVAaLMFQgs1EVmVkzp857Con2mgPtKX7eoHX/BWOGnmBxt/ZpaWZGpN39Ome+sus7V/yAwNDJht/U/Y6XV9e0qyddD8zSaucB9Pbnz8FbOkVL5btu2w5frEwHYbeTyS7WZ7/8j8zlK5L+4+ZLf17vPRFysyW5Hae1bQOk+8+cbqY+abbYPBJxHUQ+s/pDYbILQACSJ3BPvK7G5vZZNGbnr856a954DpL0lrf/+gGRwlWNUZLMnWQGm9gYFBu51s79svGckNj71iFnU/b8v4if5yOT70eJ+5q2Nz3ch6so2Uuciw7Mvdd3iYNo200ko/anddQiRfn9dr3vnNheATCSA/ILQACfLki6/HchOFiUZEdOWWA7Y1cHtJTsPi2khEfmV7xDY6Ui6b+nZXRFYjsvrl2zeaaxb1RObyn2y0641st91s3TZU1UIuY8aGZVZupvGjtsfsKAbusRAikZstbPnpyeATCSA/ILQACfKD1U+a6fc/761okop0LZBuBCKyG7u3mmsXdNm/rnDViqx7TWmbRzaWtxGxlf39aNPfep+vqLmlVM4ioE+Eyk8ionrt4tpDAf1w9a6Q0Go3hQHb/1b6yM6Zv6gisjJU283tA/aOXr7jIUQi3Z3kolSAvIHQAiSE3FP98js7zfXr0huofl5JhLb3D1opEjGdOrfLPDz0opk2r7shqZV1rry70yzvPWSumL2pIrUSEeQF3dwKVfL9jSdK5eHrI1vOeIXWzdL1Q/ZWxzKurNzpy3cchIzOaXP5HZ3m/fO/Dd5pAPkAoQVIiOdOnjXTFqc3uoHIrPTFFBkSERUxPXiifCGfPbY6UtvT22+3GXjulco2o6S2f7u5pzvdFui0Ixdw2Qu/Qt0M3MQhtL3d3WbeBkSWjD1TFu80u478IninAeQDhBYgITbvP2H7r/kqmGbnJ50vVcmsiKgIqYvIrbTY+qRWZHbGgs0VmVVOnX3PTJkz0v1AIheMze580XscRcia3qcjW2Y1cQitRFra6epBxpor2/aah3ceC95pAPkAoQVIiI6BI2bKffu9FUwz870NJ+rKrLLz8Gu2FbZrS39FmkRmvzG/2/QfPBWsVY1K7Yq1vZVtpFvDrI3HvceT54hcahnUSnxCW+6/HDWsFyG+TF3xrFmw6dngnQaQDxBagIS4c/0+M609+duPPtq714qPyKyIpwhoLaQVVlpjRWTryawi+/yLuzorUitX9T++NZ3W6DTzWN9TttU0LJ7hxCW0EhlKbdmWZ73HQ4gvVz1w2HzvgV3BOw0gHyC0AAkhVxbL7Sd9FUyzIkM8SeusyOxX7txkXvrFr4KjqY1KbSMyq5z45bvmsts2VLofyPPe1nnMe1x5zK0Nts5K4hRaiXxhkZZ433EREo7cYOGqhbXffwBZA6EFSIjpC3vNjEeSvcuW3N1LhGewv998/74t5pYHdtjRFhpBpLZr78+CqdrI/eHnPb7PPoc8l4pW17Zd3uPKY+Q2ttJaqq+9VhoV2h+v6LbdP9Zs7LM3WdCseqzPLH2010ZaxUVoO3q4QIw0lmsfPWFHOgDIEwgtQEL8+Y8fN9etTW7ILulX6d40QaVWREkENC5kX/M37DezQjIrkeefuaEYN12QGyjIa76lrauSGxZ12nx7cbf5y3s3m28t6jZT52wyX71jQ12hnbnyCfueqZdppf3J80qLePhOYoRERd47AHkCoQVICKlAfBVLszKv63DlYjCNSq20psYhtSqzNy/vHSWzEhHaIgzj9ZelLw/ad1b+zz9cvduO1atZs+sl07n3Z1U5cLw8ZFoUr775a9uNQ/LWr8+bfzj3YSU6hqjsZ9rczkp539F51Ht8hISD0ELeQGgBEiJpoZWLwVR03Ih4zlrWY0V0olIr+7hpyWavzGqKcHHYdzecqLxe+T8/feyNoISay/ZDpytCS7cDMpYgtH6mTp1qTpw4EUxBlkBoARIiaaHt3Fr+CdwXEVBpVZ2I1K7afth8+55u0781WmYlvduGvMeXp7jDdSUptPI8/+f2DZXn3ti323t8hISD0Pq56KKLbBDb7IHQAiRE0kK7tX+oIjq+TERqVw8eMTfeu6WuzErk7mG+48tTXKGVFtMkhVbeV/rcMiat7/gICQeh9aNCi9hmD4QWvIRPapK9qOTUyvb+AfP1uzaZJ198PfjP10ckSm7OsLWvvsxqfMeXp/yXP/3TymsVod32bGNDnU2UsNAWoawJSSOIbeuD0IIX3wlNspXNm8pXv0dFWmjHc4FYvQvBwhno6/MeX57ymc98pvJ6RWjlYq0k2P/yLxFaQhLI5z73OTM0NBScedCKILQACZF0l4PurbuqRMfNeGVWUamVi8vqSW1fAfrQSrYPlMegTVJoZQQEV2jlDm2+YyPVUUnxLStK6HLgx5VYCSKbHRBagIRIWmjX9D1dEZ1wfrC8x95k4eNPfh8c3dgRqfXdTCGcDQW5UGnj1ift65VxZsNC++HvPq4adkvy+tu/CZb6ee7kWdulQNL7zEm7TzcyHNjsdXurhLavvxhfHiYalRXfsqIEofWDyGYXhBYgIZIWWhmHVi7IUtnR/KSjd0x3DKtFPakdHNhulm5+znt8ecui7uft0FlXz+20/+t6qXdjBVn+1Ts32hZfuXmCiPI18zvtDRoketOG7y7pMr1Bf+Z1pS8xvmMj1UFoEdooENnsgtACJIRUIL6KpVm56fGflySzWmhvb99ibu4YikVmFZFaufuYT2pFqGWMVt/x5S1yRzR5zQ86t6XVtK/trbp1rdxFrBGhlVvkuuVZKyLTi7sPeY+NVAehRWghfyC0AAmRtNBK5Od+FR4rs/c/0bDM7nnp70z/wcau1pd9SqtvWGq7t+3yHldes77vqcodw2pFRDVuoZX8zaaXvcdFqoPQIrSQPxBagIRIQ2hlfFS5/e36zq3msts2mJd+8avgaGpz8MQZM3Vul/nG/O6GpVb6hMpzyHOJXEnr7OyuYt2K9VZnPNpaiVtoRaJ7tu3wHhMZHYQWoYX8gdACJEQaQitZ37fHDJaEZ8XaXvMXd3WaU2ffC47Ij8rsxu6tpqe331yzYLMZeO6VYKmft3593kyfv9k+h0rWxq3FvGvVI71P277DrnCG0wyhndt1xHs8ZHQQWoQW8gdCC5AQaQnt9zeeMNv7B634iHBOmdMVKbVyZf20ed1WZlWWNm/ZZq68u9PsPPxasFY1si8RZVdmpVX4Bxt/5j2evOd7G8rlXavrQZxCq62zNzzuPx4yOggtQgv5A6EFSIi0hFZyV9eLZvtAWWof2bjVK7U+mdXIPGm1ldZbF5/Miswt6D7sPY6i5I7Oo4kK7W2bXvIeB/EHoUVoIX8gtAAJkabQSuQKeB3GS6RWbl8rEivIX5n2yaxGpVa3EZkVMa6S2ZI0t20+6H3+omWxHcZrdDlK4hJa2X9RhkWLMwgtQgv5A6EFSIi0hVZSltqRllqR2IeHXrR/ZTosTOGI1EorrgzsLzLrbiOyvGwLMuumrSSbUjZhsY1HaLebh3v3eZ+X1A5Ci9BC/kBoARKiFYRWclvnMTPQ/0RJsrYH3Q86G5JZjUitu43ImsjsTzr52duX2Z0v2i8RUt5ahiKqX759o7lmUU9kZHktoV3Z8yz9ZscZhBahhfyB0AIkRKsIrURudrC6d7/tIrC93y9MtSLbWJEtbS+thEW5ecJ4M2vjcdO5dZctOxFbubmCyGq9yHpuucvoCVLuchc43/OQxoLQIrSQPxBagIRoJaHVyBX5q0piK6IkIxO48hQVaY2V9UVkZXvffok/d3W9YEckkHKsN7SXG7njm4jsg70/pcxjCEKL0EL+QGgBEqIVhVYjP13LTRhWbjlgWxL7+odM+8p2c9cdd9gWRZmW+e1bnrFdFm547BXvfkj9SFlLN4RVPftNf/8TVlg7Vq40s++400quRmW2e+tO2xcXkY0vCC1CC/kDoQVIiFYWWl8u+fxl5uJLPutdRuKJyK3crvZP/tuXzH/4gz+xIxZI5ncfNnd3vUBXjiYFoUVoIX8gtAAJkSWhvWLBYKXS/9LNq73rkHhCWScfLW/fsqIEoYW8gdACJESWhFZaZ7XSp5W2uaGsk4+Wt29ZUYLQQt5AaAESIitC67YYamg5bE4o63SiZe1bVpQgtJA3EFqAhMiK0LothhpaDpsTyjqdaFn7lhUlCC3kDYQWICGyILS+FkMNLYfxhrJOL1rOvmVFCUILeQOhBUiILAitr8VQQ8thvKGs04uWs29ZUYLQQt5AaAESIgtC64ZKP7lQ1smG8kZoIX8gtAAJgdCSqFDWyYbyRmghfyC0AAmB0JKoUNbJhvJGaCF/ILQACYHQkqhQ1smG8kZoIX8gtAAJgdCSqFDWyYbyRmghfyC0AAmB0JKoUNbJhvJGaCF/ILQACYHQkqhQ1smG8kZoIX8gtAAJgdCSqFDWyYbyRmghfyC0AAmB0JKoUNbJhvJGaCF/ILQACYHQkqhQ1smG8kZoIX8gtAAJgdCSqFDWyYbyRmghfyC0AAmB0JKoUNbJhvJGaCF/ILQACYHQkqhQ1smG8kZoIX8gtAAJgdCSqFDWyYbyRmghfyC0AAmB0JKoUNbJhvJGaCF/ILQACYHQkqhQ1smG8kZoIX8gtAAJgdCSqFDWyYbyRmghf+RDaN/abq6/tMMcCiZbgbd6bzULDwcTACUQWhIVyjrZUN4FF9oiO0OCr72h1xTj8cQvtMHBLVx6pfnCpVNGsvRosEITONxhvjBzu3krmEyfd0znzCtzK7RvHT7aQmWdHRBaEhXKOtlQ3i0ktDhDiQSdIbHXXv2aIr0hxuOJXWgPVd6UjRu3WPz1ve8EU2NHnnMi28fPUbPw0ltNZ/Afmujri4PYjsF++ORX1psJQkuiQlknG8q7dYQWZxCSc4bkXrvzmmp4Q5zHE7PQygsYu+zICxq/II3vOZtK6BvHxF5fPLTCMRQdhJZEhbJufi75/GWVcg7n4ks+690mz2kNocUZLIk5Q4KvvaGW13iPJ16hrdcXIrB0+22s8kLlBZW+jcz0f0uTbyrl+VNCFl8uiHrbNPqzRfQ2zvM48+UNN3I81f8Uu6/Kuo2/vvEca+UY7JunwyysPM/It716x1B5jZXnD34q6NX/V/U3R/fN5z/+6O2LDEJLokJZNz9XLBislHM4X7p5tXebPKclhBZnsNh9VdZt/PU1eqy1XntlWSP78v4/qo9JX6P7muRxtbRGH49vX40Sq9DqC3APqHKwtiBCYiMSput5ClPeAFpo7jcW3b+dDn0LKC9znzP8zxtN9DZlMRtdqNVvxurX5vQbqfP6xnOsUWVi52uZjOEYysvl2J1tgu1VRGXf5TJw16lfbqO3LzYILYkKZZ1MfK20RWydlbSC0No6BGcYqVeb4Ay1Xru//o/A9/8o4S9zd3/V+651PFH/v0aJUWjLB23/EW6BKbYwSstD/yQ5aK/sVL1QeTMEBWn/ASP/RFs4us/Qsob+4bW2CRV2hdB+7TH4jrVEzdc3nmP1PU9429B05DHY9cr7sG+kyjbVr6GCu9+axx+xfcFBaElUKOtk4mulLWLrrCR9ocUZRh1rididIfy8+trt9r76PwK7fuj/UfV63dfhPA6XT9TxRO6rceIT2kYKt0S54PRAQ98KZB/Bi5P1dL7dJnih7nzdXv/51ctChRVBrW3Cy5Tq/UrBO//kqn9KY69PGOuxymN9nvC21dNRx+B8mOi3JaXqNTg482sef9T2BQehJVGhrJOL20pb1NZZSepCizOUJxNyhurXXqP+r4Ps0/31Vbe18/V1uK8p0hui/xdV+xoDsQmtLVznAOwB+Qy76k3s/PPsfPdNO1JgttDtP85Z3/mHuP+gSmFJIdY9WWptM3IM4fXCb+DrS+vpdPWbzNlu1Osbz7H6yqQ8XdlXeN+RxxAce/BmEuTYZTrqRBlZv/bxR21fdBBaEhXKOrm4rbRFbZ2VpC20tp7AGUL1pbNdLM6g25Qfj7z26Pq/LpX/h+zTV+ae1zuqvMPHE72vsRCb0FYOIkh1wQTfSGRZ2LrtP0a20X9cGVsgpfny4t2C1/nl9d0CcpeN3l8UtbZxl1XeSELlmMuv06436p8XUOf1+ZZFodtUl8nIG8FSdfIHRByD+zpsol6DpfongFrH798eEFoSFco62UgrbZFbZyVpC63UE279U11n4Ay19j32Yx392qPqfz/+/4fuP1zmI4+jvGH08UTtayzEelEYAESD0JKoUNbJRlppi9w6K0lbaAHiBqEFSIisCe1//frNNr5lecqPBiennv9xzSQb37Ik4yufZsQ8V6p6iI2vfJIIQgt5o3RGAUASTFRoz83/fKHiK4NmRETu7X/8u8IncaH9p5cJQgsQGwgtQELEIbSf/N/XChGENvkgtCkEoQWIDYQWICEQ2saD0CYfhDaFILS54cCBA8EjSAuEFiAhENrGg9AmH4Q2hSC0uaGtrS14BGmB0AIkBELbeBDa5IPQphCENhdcuHDBtLe3B1OQFggtQEIgtI0HoU0+CG0KQWhzwRtvvGE2b94cTEFaILQACYHQNh6ENvkgtCkEoc0F+/fvN4cO1b5vFzQfhBYgIRDaxoPQJh+ENoUgtJnn008/NR0dHeadd8Z+ZyuIF4Q2QwwPDwePIIsgtI2naEL7h3/0B/ZOYb5lSQWhTSEIbeY5fvy42bBhQzAFaYLQZgjpdP7hhx8GU5A1ENrG06pCe/c9d1jxlL/u/Bu+c52d//CGjqr5jWYsQnvpZf/brnv45DPe5eNNqwvtmVM77et2M+mP/qN33ajI+rKdb9l4M57jqAShzTTaOnv27NlgDqQJQpsh5Fvge++9F0xB1khSaN1KX/Pc0Bbvus3M5X9Wlq83XtjnXR4VhDY6RRTavo1t9jVPvux/VuYN73vczpO469YKQjsShHbi0DrbWiC0GaKnp8e89tprwRRkjaSEVuRRKtn/9IeXeJcnmSIKrYimrqPyqct0fXms82WdsNC6yyX6fLqeRqZ1m/Aynd9oWlloVUSlldadP2vm1Xb+8sU/tNPy2JVLXe7Kr0bkWFt9ZXuZ1mUi0LK9bif70X26x6Lra9z1GgpCm1nk19Jly5bROttCILQZ4siRI2bv3r3BFGSNVhFaaal1K2F3ve99+1o77765t9u/Mu3Od6PLtjzaXjVftpX5sl93/lgEOw9C666nsinLdLmIrLtPiUzLPnSZJNwiG56WhIVYHrv7aCStKrQqjr5W0HDLbXg9V2hlWmVUl7tSqlLsCmstodVpeew7toaC0GaSjz/+2Kxbt467g7UYCG2GePvtt+1JBNmkFYRWZVZlVNeVllSZdsVVt1Fh1S4L7vq6TCVWRVjXLXILrdt6qtvJcvexLg8LqRvd9+DeXjsdFlqZL9OyXngbV3rrpVWFVqXSJ41xCa27jYitzJN9I7QQRlpm16xZY7Zt2xbMgVYBoc0Qn3zyif2J49133w3mQJZIWmjDkfk+wXTnqdCKqOpyneeur7Ic3p8+twozQjt6u0aEVqfd1BNaX4oitCqc4fUmIrTyF6EF5dy5c7ZFVm5xS8tsa4LQZgzpdtDX1xdMQZZohRba8QhtuNVVHoeFNZy8Cq1IqLwetzVU4rai1hLaRlpow62r7r5lupEW2vGkVYVWIq9PIgLqzldh1T6v8jguoaWFtthIS6zcMEF+FV28eLF56KGHzNDQkBVbaE0Q2owhfXfkGyInVfbIqtBqtwKNu996wpo3oZVoOahQqsBqn1Wdlqi0qrDKMhVQXV8FVyLTYWHVbVVow4LrrqPT40krC61KpiuWvpZblU23/6tEhVYv/FIxVqGVqBS7+wgLrx6HRKbd9XV6TEFoWxIZvWDJkiVmz5499oYJ8usotD4IbQaRnzt27ix9IEOmaAWhDfd5Dfep9QmtSKlvX5Lw/sLR/WnrbqNpZaGVqEBqVE4lKrSyjsqpxBVQV2JlHZVUd3t3ufzV7d3l8hy6T52ncY+pkbSy0Eq0e4EbV3AlrsRKdBsVWne5O8qBSKk7yoGuL3ElVtbRVl9d7h5X+HjqBqFtOaRVVsaWff/994M5kBUQ2gwiP4XIt8cLFy4EcyALtILQSrQLgUZlVuITWpVeNyK5ujy8P4kKrB6LJOp4fGl1oa0VV2h9y1s1rS60zUi4BTbxILQtxdGjR63McgOjbILQZhS5De5jjz1m71QC2SApoY07IqKujKrARrXKxhGENvkgtP51mhqENjWkG8E///M/B1PGXmwtDUW0zGYXhDbDyMVhMnQIUpsNsiq0UuG7QutrxY07CG3yQWj96zQ1CG1qSL25aNGiyniyUpdKdwPILghthpELxDZv3mxvvffRRx8Fc6FVyarQ+rocNFNmJVkW2qymiEKbehDaVJHxZOfNm1eJXHA9MDBgTp48WdV6C9kAoc048i1T7h4mJ6J0Qzh//nywBFqNrAptGkFokw9Cm0IQ2lSRi6tdodXIeO90PcgeCG1OkGG85CeTVatW2THz5Jvn7t27Gd6rhUBoGw9Cm3wQ2hSC0KaKXAQWllmpP2WoLsgeCG0Okc7u0sHdvasJ/WzTB6FtPAht8kFoUwhCmyoirq7MLliwwJw9ezZYClkDoc05MvyIjIbQ09Nj+9xCeiC0jQehTT4IbQpBaFNFGn9coT19+nSwBLIIQlsApHVWOrrLBWSQHght40Fokw9Cm0IQ2tSRW9qKzMpt5SHbILQFQaRWRkM4ePBgMAeSBqFtPFkXWvdOYBq9DW696J3BZPgv3/JmJetC697RS6O3s62X8C1xEwtCmzrS2MNwXfkAoS0Q0v1AOrxzF5R0aBWhDVf6jd7BK3yb3GYmy0Ir489KOYUFVuY1IqkI7dgj48hKmYUFVuY1IqkIbXFhNIP8gNAWjMHBQTu8lwtj2CZD2kIrY8dKpR0WWLnjVyOSitDWj7bMyl/fcs3g3l67nuaG71xn56sMa9ybM4SX6fy4klWh1ZZZ+etbrhne93hV+c2aebWdrzKscW+yEF6m82MLQgsQGwhtwZArOGVoL+kvJBeKya3+Tp06FSyFZpK20Gql7Fvm5vI/K7cQat54YV9Fht3ozRXCy+K4JW5WhVals1brqsisK6ois7KNzJdpXwut7len5bGsp9NxJKtCq9JZq3VVZNYVVZFZ2Ubmy7SvhVb3q9PyWNbT6ViC0ALEBkJbAGR0A1dg3as6JdyMIRnSFFqVznqtqyKzKqoisrKNzJNpXwut7lclVv7KtKyr64wnWRfa8LTGJ7raqqtdFMJCq6252oorUQmOs1tC1oU2PK3xia626moXhbDQamuutuJKVIJj7ZaA0ALEBkJbEOSmC2GRlcgdUSAZWkFoVTzDrapRoivLtIuCT2i1NVfkV6ZVgifaLSFvLbTh+SqtbuoJrS8IbXQLbXi+SqubekLrC0IL0JogtAVBxtuT8WjDQiuttpAMrdhCG56v0uqmEaENp6hCqy2n4QvCXKHVFlntYjCeFtpmJKtCqy2n4QvCXKHVFlntYjCeFtqmBKEFiA2EtkDI6AYdHR1VQhu+QAyaR5pCqy2n4QvCwkIrj7WLgU6PpYU2rmRVaCVSHhIVVokrtFF9ZlVow8vd7XW6Gcmq0EqkbCQqrBJXaKP6zKrQhpe72+t0U4LQAsQGQlswZIgSuR2uCu2bb74ZLIFmk6bQSrR/qyusrtBG9ZlVoQ0vd7eP40IwN1kWWolKqRuRUl3uzg8LrUivLovaRiLb6bI4kmWhlaiUuhEp1eXu/LDQivTqsqhtJLKdLoslCC1AbCC0BUQkVu5ZLZGuCJAMaQutRKU0HBFTWa7SqxF5dVt1RXzrbSMRGdZtxpOsC20Wk3WhzWQQWoDYQGgLysmTJ82aNWuCKUiCVhDarAShTT4IbQpBaAFiA6EtMNwhJVkQ2saD0CYfhDaFILQAsYHQAiQEQtt4ENrkg9CmEIQWIDYQWoCEQGgbD0KbfBDaFILQAsQGQltgPvjgAzNjxgxz8cUXVy7mkWmZD/GD0DYehDb5ILQpBKEFiA2EtsDIGLTulemaOXPmBGtAnCC0jQehTT4IbQpBaAFiA6EtMGfOnDF9fX2VFtm1a9daoZ08ebKdhnhBaBsPQpt8ENoUgtAmitR3X/ziFyuNN5MmTbLzIB8gtAVGRHbWrFn2pNYTfCxCu3z5cru+/IX6ILSNB6FNPghtCkFoE0XqNreu09DNLh8gtAVGZFZOZv2GGm6hlfkyLS25YWQZQjs2ENrGk7TQtkq+2f6/zNdnf967LIn4yqcZsUJLbHzlk0SK2kIrY7ALIrHamMMt4PNB6YyCoqJCG44IrUisOy/qZxlZhtA2RhxCW6T4yiDvueTzl5mLL/msdxmJL/q55ltWlBRRaJ966ilvKy1Cmw8Q2gIj0qont4x0IBeDyeNGWmgVWY7QNsZEhZbkO1csGLTnk+RLN6/2rkPiiZazb1lRUjSh1UYaaZXVae1Pq0Irj6nPsgtCC5G4QuuOiCAtuwofAI2D0JJakdZZPcdopW1utJx9y4qSogqtL1K/uS232qgD2QKhhUhUYmmhjYcsCq20GtJa2Py4rbMayr150TL2LStKiia0glwnouOuS+usjLsuj2mhzQcILdREP/j1hFe09VajP+NANFkUWvp0JhO3dVZDuTcvWsa+ZUVJEYW2HvKeQGizC0ILkBBZE1r6dCYTX+ushnJvTrR8fcuKEoR2NNIwg9BmF4QWICGyJrT06UwmvtZZDeXenGj5+pYVJQjtaHTkH/c6EcgOCC1AQmRJaOnTmU60rH3LSHyhnBFayB8ILUBCZElo6dOZTrSsfctIfKGcEVrIHwgtQEJkRWjp05letJx9y0h8oZwRWsgfCC1AQmRFaOnTmV60nH3LSHyhnBFayB8ILUBCZEVo3VDxJxvKu3n57Je/bf79f/7vNlrOOv2H//0K7zZ5DkILeQOhBUgIqUCuW3vKW7m0ahCsZEN5Ny/SXUbLN5wvzJjt3SbPQWghbyC0AAkxZX6PmfHIy97KpVWjFb5vGYk/lHdzI11mtIw1/+bf/jtz7aPHvevnNdc+esJ8+faNwScTQD5AaAFi4t577zWbNm0yn3zySTCnmptW7jBXP/iit4Jp1Wil71tG4g/l3dz4WmmL2Dr7jdXHzFUL+4JPJvAxdepUc+LEiWAKsgBCCxATN954o60g//iP/9grtneu32emtT/nrWBaNVrp+5aR+EN5Nz9uK20RW2clVz1wxHy3Y1fwyQQ+9D2C2GYHhBYgJlRoNWGxXblt2Ey976feCqZVo6/Ft4zEH8q7+XFbaYvYOiuRL9bzNh6wn0vgR98jGsS29UFoYRThE5lMLCq2nU+/7F1OCCEkG0FsWxeEFkbhO4nJ+POZz3zGLFy40Ox6/qR3OSGEkGzkc5/7nBkaGgpqS2glEFqAmAh3OVCRPX/+vF3+j7/9yFx+Z6e5fv0r3p8BWzH6WnzLCMlyith3tpzT5iuzu837539rP5fAj/tZLkFkWx+EFiAmVGjDIuty86rd5qoHDnsqmdaMfpj7lhFCspdvrD5qvtk2GHwiQRSIbPZAaAFi4kc/+lGkyCpDw6+aq9qe8lY0rRiElpB8ZWrbHtO1jz6g9UBkswdCC5Ag8jPfV+/q9lY0rRiElpB85Wtze81bv47+0g2QVRBagIT5zsod5Z/9PJVNqwWhJSQ/kTsVXr1oa/BJBJAvEFqAhHn62Btm2uJBb4XTakFoCclPpi/ZaZ54/tXgkwggXyC0AClww32D5uoHX/BWOq0UhJaQfER+FZLW2d9/+mnwKQSQLxBagBR46Re/MlMWbPNWPK0UhJaQfGTqPdvNgeNngk8ggPyB0AKkxKwHd9tbUPoqn1YJQktI9jP9/mHzrfsYqgvyDUILkBKvv/0b87W5Pea6tae8lVArBKElJNu5ft2p0udMnznxy3eDTx6AfILQAqTIut1/a6beIxeInR5VEbVCEFpCsp0pi3eYZX3PB584APkFoQVImTvX7zPTWvRmCwgtIdnN1Pv2mltW7+ZCMCgECC1AyvzuX/7VfLNtwExfedBbKaUZhJaQbGb6/YfsqAYf/u7j4JMGIN8gtAAtwD+c+9BMmd9jrn7wRW/llFYQWkKyFxmi6y/mbOaOYFAoEFqAFuHU2ffMlfN6zPQWGvkAoSUkW5GWWZFZ+TwBKBIILUALIS2117cNmClLpU9t+heKIbSEZCfSZ1a6GdAyC0UEoQVoMaRP7W2P7jVT7nki9SG9EFpCWj8yNJeMZiAXgNFnFooKQgvQgshVyQ/vPGaumLPFTL//eW8llkQQWkJaO3LTBBlnVobmYjQDKDIILUALI4Ohz2zfYa5c0J/KBWMILSGtGbnwS25nK3cA46YJAAgtQCYYPvWmmbG430xfssNc89AxbwXXjCC0hLRWZjzyculzYKftK3vg+JngEwIAEFqAjCA/J+556Q1z3ZIB8/V5vfbCsasffKFUyTXv4jGElpC0c7rcGtu2x3xtbq8V2Seef5XuBQAhEFqADPLOby6Yrn0nzE0rd5jL7+g0U+7dZa5s22umrnjWXPXA4VIFeMxc++gJT+U4tiC0hCQTOV/lvL3qgSNmWvtz9nz++j07zVdmd5tvtg3a853RCwCiQWgBMs77539rhoZftReRLdj0rPneA7vMVQv7rOj++Y8fn1BUaH3LCCHx5cu3b7Tn7Xc7dpl5Gw+Yh3a8ZM9rOb8BoD4ILQBEokILAADQylBTAUAkCC0AAGQBaioAiAShBQCALEBNBQCRILQAAJAFqKkAIBKEFgAAsgA1FQBEgtACAEAWoKYCgEgQWgAAyALUVAAQCUILAABZgJoKACJBaAEAIAtQUwFAJAgtAABkAWoqAIgEoQUAgCxATQUAkSC0AACQBaipACAShBYAALIANRUARILQAgBAFqCmAoBIEFoAAMgC1FQAEAlCCwAAWYCaCgAiQWgBACALUFMBQCQILQAAZAFqKgCIBKEFAIAsQE0FAJEgtAAAkAWoqQAgEoQWAACyADUVAESC0AIAQBagpgKASBBaAADIAtRUABAJQgsAAFmAmgoAIkFoAQAgC1BTAUAkCC0AAGQBaioAiAShBQCALEBNBQCRILQAAJAFqKkAIJKDBw/aAAAAtDIILQAAAABkGoQWAAAAADINQgsAAAAAmQahBQAAAIBMg9AC5Ijh4WHvyASTJk1itAIAAMgt1HAAOWPWrFlWXpcvX26n5a87DQAAkDcQWoCccebMmUorrT6WFloAAIC8gtAC5BBtldX09fUFSwAAAPIHQguQQ9xWWlpnAQAg7yC0ADlE+9Fq6D8LAAB5BqEFyBk60sHkyZOrWmoVabFFcAEAIE8gtAA5Q4foErEVtD+ttNq6fWtlGgAAIA8gtAA5Qi7+ElmV1lkXlViRXFpoAQAgbyC0AAUDoQUAgLyB0AIUDGm9RWgBACBPILQABUP70SK1AACQFxBaAAAAAMg0CC0AAAAAZBqEFgAAAAAyDUILAAAAAJkGoQUAAACATIPQAgAAAECmQWgBAAAAIMMY8/8B08HUNcW0z2MAAAAASUVORK5CYII=)

**Objetivo del Ejercicio**: Tomando como referencia los datos de un Instituto de Biogeoquímica que contiene el registro histórico de diferentes variables climáticas, queremos elaborar modelos predictivos basados en Redes LSTM para predecir la temperatura.  

*Info: La Sociedad Max Planck es una de las organizaciones de investigación más importantes de Alemania. La sociedad cuenta actualmente con 84 institutos y organismos que se dedican a la investigación básica de las ciencias naturales, biología, humanidades y ciencias sociales al servicio del interés público.*

**Variables del dataset:**  

*p (mbar):* presión del aire en milibars  
*T (degC):* temperatura del aire en °C  
*Tpot (K):* temperatura potencial  
*Tdew (degC):* temperatura de punto de rocío (a la cual el vapor de agua se condensa)  
*rh (%):* humedad relativa  
*VPmax (mbar):* presión de vapor de agua de saturación  
*VPact (mbar):* presión de vapor de agua real  
*VPdef (mbar):* déficit de presión de vapor de agua  
*sh (g/kg):* humedad específica  
*H2OC (mmol/mol):* nivel de concentración del vapor de agua  
*rho (g/m**3):* densidad del aire  
*wv (m/s):* velocidad del viento  
*max. wv (m/s):* velocidad del viento máxima  
*wd (deg):* dirección del viento  
*SWDR (W/m²):* Environmental variables-global radiation  

**La variable a predecir es la temperatura (columna T (degC) de nuestro dataset).**

Origenes de datos: https://www.bgc-jena.mpg.de/wetter/weather_data.html

**Carga de Librerías**
"""

import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from scipy.stats import pearsonr
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller
from sklearn.metrics import mean_absolute_error, mean_squared_error
from scipy.stats import jarque_bera, shapiro, boxcox, probplot
from statsmodels.graphics.tsaplots import plot_pacf, plot_acf
from statsmodels.stats.diagnostic import acorr_ljungbox, acorr_breusch_godfrey
from sklearn.metrics import mean_squared_error
import math
from statistics import mean
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.optimizers import RMSprop
import tensorflow as tf

"""**Carga de datos**"""

url='https://raw.githubusercontent.com/braiandrago/AST/main/temp.csv'
temperatura = pd.read_csv(url, encoding='latin-1')
temperatura.head()

"""Que observamos? Frecuencia de registro de datos?

# Procesamiento de datos
"""

temperatura.info()

"""En los siguientes pasos:  
-Convertimos la columna Date Time al formato datetime  
-Fijamos esta columna datetime como el nuevo índice de nuestro DataFrame      
-Orden cronológico ascendente
"""

temperatura['Date Time'].dtype #otra forma de verificar

temperatura['datetime'] = pd.to_datetime(
    temperatura['Date Time'],
    format = '%d.%m.%Y %H:%M:%S'
)

temperatura = temperatura.set_index('datetime')

temperatura.sort_index(inplace=True)

temperatura = temperatura.drop(columns=['Date Time'])

temperatura.head(3)

"""**Visualización del set de datos**"""

import plotly.graph_objs as go
from plotly.subplots import make_subplots

# create a list of available columns
available_columns = temperatura.columns.tolist()

# create initial visible traces
visible = [True] * len(available_columns)

# create subplot
fig = make_subplots()

# add traces
for i, column in enumerate(available_columns):
    trace = go.Scatter(x=temperatura.index, y=temperatura[column], name=column, visible=visible[i])
    fig.add_trace(trace)

# update layout
fig.update_layout(
    updatemenus=[
        dict(
            type='dropdown',
            active=0,
            buttons=list(
                [
                    dict(label='All',
                         method='update',
                         args=[{'visible': [True] * len(available_columns)},
                               {'yaxis': {'title': 'Values'}}]),
                    dict(label='None',
                         method='update',
                         args=[{'visible': [False] * len(available_columns)},
                               {'yaxis': {'title': 'Values'}}])
                ] + [
                    dict(label=column,
                         method='update',
                         args=[{'visible': [column == col for col in available_columns]},
                               {'yaxis': {'title': column}}])
                    for column in available_columns
                ]
            )
        )
    ])

# update x-axis
fig.update_xaxes(
    tickmode='linear',
    tick0=temperatura.index[0],
    dtick='M1',
    tickformat='%d.%m.%Y')

# show plot
fig.show()

"""**Análisis de datos faltantes**"""

print('Cantidad de NaNs:')
for column in temperatura:
    nans = temperatura[column].isna().sum()
    print(f'\tColumna {column}: {nans}')

"""Se observa que hay 1 valor faltante en la variable densidad del aire y en la variable dirección del viento. Utilizaremos interpolación para completarlo."""

columns = ['rho (g/m**3)', 'wd (deg)']

for column in columns:
    temperatura[column] = temperatura[column].interpolate(method='linear')

print('Cantidad de NaNs:')
for column in temperatura:
    nans = temperatura[column].isna().sum()
    print(f'\tColumna {column}: {nans}')

"""**Análisis de la periodicidad del dataset**

Debemos asegurar la periodicidad observada anteriormente...a lo cual,verificamos si entre muestras consecutivas del set de datos existe una diferencia temporal de exactamente 10 minutos

Se utilizan funciones de Pandas dataframe: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html
"""

df_time_diffs = temperatura.index.to_series().diff().dt.total_seconds() #total_seconds es una función de pandas que retorna la duración total de cada elemento expresada en segundos.
print(df_time_diffs.value_counts())

"""Frecuencia de toma de datos cada 600 segundos (10 minutos). Las que estarían bien.  
Queremos corregir las de Frecuencia de 0 segundos indicaría un valor repetido, las de 300 y la de 1200seg.  

"""

temperatura.drop_duplicates(keep='first', inplace=True, ignore_index=False) #eliminamos repetidos

df_time_diffs = temperatura.index.to_series().diff().dt.total_seconds()
print(df_time_diffs.value_counts())

df2 = temperatura.asfreq(freq='600S', method='bfill') #convertimos la serie de tiempo a una frecuencia determinada (para completar se utiliza el valor del siguiente punto de datos disponible).

df2.info()

df_time_diffs = df2.index.to_series().diff().dt.total_seconds()
print(df_time_diffs.value_counts())

"""Ahora, el set de datos ya tiene la periodicidad requerida"""

#df2.to_csv('/content/drive/MyDrive/Colab Notebooks/AST_Online_2023/temp_preprocesado.csv')

"""# Modelo univariado-unistep  """

df2.head(5)

"""A la entrada del modelo introduciremos una única variable, mientras que a la salida también tendremos una única variable pero intentaremos predecir sólo 10 min a futuro (**“unistep”**).

**División de los datos: Sets de entrenamiento, validación y prueba**  

A diferencia de otros modelos de Machine Learning, en el caso de series de tiempo y las Redes LSTM se debe garantizar que se generan las particiones sin mezclar aleatoriamente los datos.
"""

def train_val_test_split(serie, tr_size=0.8, vl_size=0.1, ts_size=0.1 ):
    # Definir número de datos en cada subserie
    N = serie.shape[0]
    Ntrain = int(tr_size*N)  # Número de datos de entrenamiento
    Nval = int(vl_size*N)    # Número de datos de validación
    Ntst = N - Ntrain - Nval # Número de datos de prueba

    # Realizar partición
    train = serie[0:Ntrain]
    val = serie[Ntrain:Ntrain+Nval]
    test = serie[Ntrain+Nval:]

    return train, val, test

tr, vl, ts = train_val_test_split(df2['T (degC)'])

# Imprimir en pantalla el tamaño de cada subset
print(f'Tamaño set de entrenamiento: {tr.shape}')
print(f'Tamaño set de validación: {vl.shape}')
print(f'Tamaño set de prueba: {ts.shape}')

"""**Ploteamos cómo quedarían separados los datos:**"""

fig, ax = plt.subplots(figsize=(16,5))
ax.plot(tr,label="train")
ax.plot(vl,label="val")
ax.plot(ts,label="test")
plt.legend();

"""**Adecuación para una red LSTM: Dataset supervisado**

Ajustaremos nuestros sets de entrenamiento, validación y prueba al formato requerido por la Red LSTM para realizar el entrenamiento y posteriormente calcularemos las predicciones.  
Para este modelo, puntualmente ingresaremos al mismo registros continuos de 240 minutos (4 horas = 14400 segundos) para la variable temperatura y el modelo deberá aprender a predecir 10 min a futuro (600seg)  

Debemos estructurar nuestros sets de la siguiente manera:  

*Entrada (X):* arreglo de tamaño batches x input_length x features  
*Salida (Y):* arreglo de tamaño batches x output_length x features

![lstm_fig_5.PNG](data:image/png;base64,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tab3qMxYnTVHbBzmltY9rTLjEAkeFiJEv5/Dli8FD/tXLXNa19Y5qwgeDVZ0EvY0NpkD0OttnkTGo/Xes/t+1L5l5N6j9jxWmXGIBI/aRfBosKKTsKexyRyAXm/zJDIerfee3fej9i0j9x6157HKjAPBoxzBo6Cik7CnsckcgF5v8yQyHq33nt33o/YtI/ceteexyowDwaMcwaOgopOwp7HJHIBeb/MkMh6t957d96P2LSP3HrXnscqMA8GjHMGjoKKTsKexyRyAXm/zJDIerfee3fej9i0j9x6157HKjAPBoxzBo6Cik7CnsckcgF5v8yQyHq33nt33o/YtI/ceteexyowDwaMcwaOgopOwp7HJHIBeb/MkMh6t957d96P2LSP3HrXnscqMA8GjHMGjoKKTsKexyRyAXm/zJDIerfee3fej9i0j9x6157HKjAPBoxzBo6Cik7CnsckcgF5v8yQyHq33nt33o/YtI/ceteexyowDwaMcwaOgopOwp7HJHIBeb/MkMh6t957d96P2LSP3HrXnscqMA8GjHMGjoKKTsKexyRyAXm/zJDIerfee3fej9i0j9x6157HKjAPBoxzBo6Cik7CnsckcgF5v8yQyHq33nt33o/YtI/ceteexyowDwaMcwaOgopOwp7HJHIBeb/MkMh6t957d96P2LSP3HrXnscqMA8Gj3KrgMVJFLL2+5VpjaXutV6ml17ZWGUvbaa2ylrbVWtWy9LP3VFG6uO+59iQdPAAAAKIIHgAAoBqCBwAAqIbgAQAAqiF4AACAagge2MS77747PXjw4PgIAPqicxy2QfDAJi5dujT98MMPx0cA0Bed47ANRhKbePzxxwkeALr0888/Ezw2xEhiE0888QTBA0CXdG579NFHj4+wFsEDmyB4AOiVzm06x2EbBA9s4rnnnptu3759fAQA/bh79+709NNPHx9hLYIHNvHqq69ON27cOD4CgH58+eWX00svvXR8hLUIHtjEO++8M33wwQfHRwDQj08//XR6/fXXj4+wFsEDm/j444+nt9566/gIAPqhD1bvvffe8RHWInhgE/r7Hc8+++zxEQD048UXX5w+//zz4yOsRfDAJvRbSx955JHpp59+Oi4BgPbpd3jon9L++OOPxyVYi+CBzbz22mvTK6+8cvjVwhR1XqW/6Gf0TdvSOhS1Vem89vLLLx9nHLZA8MBm9IlAfw66dPBS1Fb12GOPTd999930/fffH+4vrUNRW9XVq1f5tmNjBA8ATdFf9HvzzTcf3gJoC8EDQFPu3LkzPfPMM4e/8PfFF18clwJoBcEDQFP0l/30F5n1HxPyl5mB9hA8ADRHoUPhA0B7CB4AmqPfGfPUU08dHwFoCcEDQHP0zxuff/754yMALSF4AGiOfreCCkB7CB4AmkPwANpF8ADQHP2HhAQPoE0EDwDN0W+UJHgAbSJ4AGiOgge/tRRoE8EDQHPs/9EA0B6CB4DmEDyAdhE8ADSH4AG0i+ABoDm3b98+FID2EDwAAEA1BA8AAFANwQMAAFRD8AAAANUQPAAAQDUEDwAAUA3BAwAAVEPwAAAA1RA8AABANQQPAABQDcEDAABUQ/AAAADVEDwAAEA1BA8AAFANwQMAAFRD8AA68Mn169Pbly9PX926dVzyO5/dvHlY/uG1a8cl03T/3r3DMpXuy9UrVx4us23Ya1X+9Rfh2zt3Tnwv9t7tfdtYqHQ/Stvfst/5PtD7zbwvoBcED6BxurDZxW0ePLRMFzp/IdVFzy7WCh56rR6LbcfCiS74dn++7Zrs/dv70/sSvScfPCyg6D3bfVv3oug9+H2g+wQPjIzgAXRgKRzoIq0LnC54dtHz69kFWs/ZhdAu1jd/+cvDrdHFUtvz9LyV2DZV9vP8Mr98zq+jOunCbNuzMKH3Zct060OU2HKj+3pepedsbHTfXmfLbKzseZVnY+XL/yxZ2gf+56u0nfnPEnveHgO9IHgAHVgKHnqsi5q/6OkiqNJ6ej4bPOwCbuznWyDQfa2jbdt78s9n6WdaL/YefO8lwcPeh/WqZf7923jZMuvb3y8136b4HuY/y/aD9Qb0iOABdMBffEUXyJMubrq1C7Du67lo8BAt0zp6vb3Ol9a3n6Oy97PEv05l78fTMj1n9PN9aNB9/Ux/wbblxvdt71m3fhvz8bLXz8dgqWf/s5b2gWg71p9ul36W+PEFekLwADowv3DZRdrXLz766A+W2UXQLtZ24V66KOv+nD33q6+/XlzHtrWW9aOfZ/R4XhaYtJ714F+j8Zk/r1vrQ89bSPDLRL344HGWpX1g46vnbJ2TgofYct0CvSB4AI3Txcxf3OafkO1C6vkLsPjXW1DwF067UBr/M23b8/eh7cyXzS+sJezi68u/n/lFW+/H1tPP93zf5x08PNumlASPpfEFekHwAHAu7GLqg8w8wAAYD8EDwLnRp3X75K5SGAEwNoIHAACohuABAACqIXgAAIBqCB4AAKAaggcAAKiG4AEAAKoheAAAgGoIHgAAoBqCBwAAqIbgAQAAqiF4AACAaggeAACgGoIHAACohuABAACqIXgAAIBqCB4AAKAaggcAAKiG4AEAAKoheAAAgEqm6f8AtXiXSxzOjzMAAAAASUVORK5CYII=)

donde:

**batches** es el número total de datos de entrada y de salida. Por ejemplo, el set de entrenamiento tiene un total de 7338 datos pero estos deberán ser divididos en bloques consecutivos de 25 registros (240 minutos de entrada + 10 minutos de salida). Cada uno de estos bloques será un dato de entrenamiento y los batches serán simplemente el número total de bloques de 250 minutos.  
**input_length** es el número de registros consecutivos que usaremos a la entrada del modelo. En nuestro caso este valor es igual a 24 (240 min (24 regx10min)) y esto se convertirá en un hiperparámetro del modelo que se podrá modificar y que impactará el desempeño del modelo obtenido.  
**features** es simplemente el número de variables de entrada o de salida que usaremos. Como estamos usando un enfoque univariado y a la salida haremos la predicción únicamente de la variable temperatura, en ambos casos tendremos features = 1  
**output_length** es el número de horas a futuro que queremos predecir con el modelo. Por tratarse de un enfoque unistep, en este caso tendremos output_length = 1

Teniendo en cuenta lo anterior, podemos concluir que cada subset (entrenamiento, validación y prueba) deberá ser pre-procesado para obtener los arreglos X (entradas) y Y (salidas) los cuales tendrán estos tamaños:  

X: batches x 24 x 1  
Y: batches x 1 x 1

Creamos la función para el procesamiento necesario
"""

def crear_dataset_supervisado(array, input_length, output_length):

    # Inicialización
    X, Y = [], []    # Listados que contendrán los datos de entrada y salida del modelo
    shape = array.shape
    if len(shape)==1: # Si tenemos sólo una serie (univariado)
        fils, cols = array.shape[0], 1
        array = array.reshape(fils,cols)
    else: # Multivariado
        fils, cols = array.shape

    # Generar los arreglos (utilizando ventanas deslizantes de longitud input_length)
    for i in range(fils-input_length-output_length):
        X.append(array[i:i+INPUT_LENGTH,0:cols])
        Y.append(array[i+input_length:i+input_length+output_length,-1].reshape(output_length,1))

    # Convertir listas a arreglos de NumPy
    X = np.array(X)
    Y = np.array(Y)

    return X, Y

# Definición de los hiperparámetros INPUT_LENGTH y OUTPUT_LENGTH
INPUT_LENGTH = 24    # Registros de 240 min consecutivos a la entrada
OUTPUT_LENGTH = 1    # El modelo va a predecir 10 min a futuro

# Datasets supervisados para entrenamiento (x_tr, y_tr), validación
# (x_vl, y_vl) y prueba (x_ts, y_ts)
x_tr, y_tr = crear_dataset_supervisado(tr.values, INPUT_LENGTH, OUTPUT_LENGTH)
x_vl, y_vl = crear_dataset_supervisado(vl.values, INPUT_LENGTH, OUTPUT_LENGTH)
x_ts, y_ts = crear_dataset_supervisado(ts.values, INPUT_LENGTH, OUTPUT_LENGTH)

"""Visualizamos el tamaño de los arreglos generados:"""

print('Tamaños entrada (BATCHES x INPUT_LENGTH x FEATURES) y de salida (BATCHES x OUTPUT_LENGTH x FEATURES)')
print(f'Set de entrenamiento - x_tr: {x_tr.shape}, y_tr: {y_tr.shape}')
print(f'Set de validación - x_vl: {x_vl.shape}, y_vl: {y_vl.shape}')
print(f'Set de prueba - x_ts: {x_ts.shape}, y_ts: {y_ts.shape}')

"""![lstm_fig_6.PNG](data:image/png;base64,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)

Cada dato de entrenamiento, validación y prueba tendrá un tamaño de 24x1 (INPUT_LENGTH x FEATURES) para la entrada y de 1x1 (OUTPUT_LENGTH x FEATURES) para la salida.

**Escalamiento de los datos**

Es recomendable, al utilizar modelos de deep learning, asegurar que las variables que alimentan el modelo se encuentran en el mismo rango de valores. (Mejora el algoritmo de predicción y por lo tanto las predicciones)

Lo anterior implica que la Red LSTM será entrenada con valores escalados. Recordar que, una vez entrenado el modelo y al momento de generar las predicciones, tendremos que realizar un escalamiento inverso, llevando las predicciones del rango de -1 a 1 al rango normal de temperaturas.
"""

def escalar_dataset(data_input):
    NFEATS = data_input['x_tr'].shape[2]

    # Generar listado con "scalers"
    scalers = [MinMaxScaler(feature_range=(-1,1)) for i in range(NFEATS)]

    # Arreglos que contendrán los datasets escalados (Se crean arreglos vacíos con las mismas dimensiones que los conjuntos de datos originales para almacenar los datos escalados)
    x_tr_s = np.zeros(data_input['x_tr'].shape)
    x_vl_s = np.zeros(data_input['x_vl'].shape)
    x_ts_s = np.zeros(data_input['x_ts'].shape)
    y_tr_s = np.zeros(data_input['y_tr'].shape)
    y_vl_s = np.zeros(data_input['y_vl'].shape)
    y_ts_s = np.zeros(data_input['y_ts'].shape)

    # Escalamiento: se usarán los min/max del set de entrenamiento para
    # escalar la totalidad de los datasets

    # Escalamiento Xs (aca es una sola feature, pero en un multivariado ya nos quedará a estructura)
    for i in range(NFEATS):
        x_tr_s[:,:,i] = scalers[i].fit_transform(x_tr[:,:,i]) #ajustamos a los datos de entrenamiento
        x_vl_s[:,:,i] = scalers[i].transform(x_vl[:,:,i]) #transformamos con el ajuste a val y a test tomando el rango del set de entrenamiento
        x_ts_s[:,:,i] = scalers[i].transform(x_ts[:,:,i])

    # Escalamiento Ys (Se asume que las etiquetas se encuentran en la última columna de los conjuntos de datos...ademas, en este caso es una sola columna)
    y_tr_s[:,:,0] = scalers[-1].fit_transform(y_tr[:,:,0])
    y_vl_s[:,:,0] = scalers[-1].transform(y_vl[:,:,0])
    y_ts_s[:,:,0] = scalers[-1].transform(y_ts[:,:,0])

    # Conformar ` de salida
    data_scaled = {
        'x_tr_s': x_tr_s, 'y_tr_s': y_tr_s,
        'x_vl_s': x_vl_s, 'y_vl_s': y_vl_s,
        'x_ts_s': x_ts_s, 'y_ts_s': y_ts_s,
    }

    return data_scaled, scalers[0] #útil para realizar la inversión de escalamiento

data_in = {
    'x_tr': x_tr, 'y_tr': y_tr,
    'x_vl': x_vl, 'y_vl': y_vl,
    'x_ts': x_ts, 'y_ts': y_ts,
}

data_s, scaler = escalar_dataset(data_in)

x_tr_s, y_tr_s = data_s['x_tr_s'], data_s['y_tr_s']
x_vl_s, y_vl_s = data_s['x_vl_s'], data_s['y_vl_s']
x_ts_s, y_ts_s = data_s['x_ts_s'], data_s['y_ts_s']

#Verificamos...
print(f'Min x_tr/x_vl/x_ts sin escalamiento:  {x_tr.min()}/{x_vl.min()}/{x_ts.min()}')
print(f'Min x_tr/x_vl/x_ts con escalamiento:  {x_tr_s.min()}/{x_vl_s.min()}/{x_ts_s.min()}')

print(f'Min y_tr/y_vl/y_ts sin escalamiento:  {y_tr.min()}/{y_vl.min()}/{y_ts.min()}')
print(f'Min y_tr/y_vl/y_ts con escalamiento:  {y_tr_s.min()}/{y_vl_s.min()}/{y_ts_s.min()}')

print(f'Max x_tr/x_vl/x_ts sin escalamiento:  {x_tr.max()}/{x_vl.max()}/{x_ts.max()}')
print(f'Max x_tr/x_vl/x_ts con escalamiento:  {x_tr_s.max()}/{x_vl_s.max()}/{x_ts_s.max()}')

print(f'Max y_tr/y_vl/y_ts sin escalamiento:  {y_tr.max()}/{y_vl.max()}/{y_ts.max()}')
print(f'Max y_tr/y_vl/y_ts con escalamiento:  {y_tr_s.max()}/{y_vl_s.max()}/{y_ts_s.max()}')

"""# Creación y entrenamiento de la Red LSTM

**Creación de la Red LSTM**

Elaboramos la arquitectura principal de la red:
"""

tf.random.set_seed(123) #para garantizar la reproducibidad del entrenamiento

#tf.config.experimental.enable_op_determinism() #realizaremos el entrenamiento usando la GPU proporcionada por Google Colab

N_UNITS = 128 #número de unidades del modelo (que corresponde al tamaño del estado oculto y a la celda de memoria de la Red LSTM.
#hiperparámetro del modelo a afinar

INPUT_SHAPE = (x_tr_s.shape[1], x_tr_s.shape[2]) #cada uno de los datos de entrada será un arreglo de tamaño 24 (240 minutos de entrada) x 1 (feature).

modelo = Sequential() #caja vacía a la cual se le adicionaran de manera secuencial los elementos
modelo.add(LSTM(N_UNITS, input_shape=INPUT_SHAPE))
modelo.add(Dense(OUTPUT_LENGTH, activation='linear'))

"""**Compilación del modelo**

Definimos la función de error a usar durante el entrenamiento así como el optimizador. Es decir, definimos que algoritmo matematico utiizaremos para reducir esa perdida a medida que vanzan las iteraciones.
"""

def root_mean_squared_error(y_true, y_pred):
    rmse = tf.math.sqrt(tf.math.reduce_mean(tf.square(y_pred-y_true)))
    return rmse

optimizador = RMSprop(learning_rate=5e-5)

modelo.compile(
    optimizer = optimizador,
    loss = root_mean_squared_error,
)

"""**Entrenamiento del modelo**"""

EPOCHS = 80 #iteraciones de entrenamiento
BATCH_SIZE = 256 #tamaño del lote (es decir, 256 datos de entrenamiento en cada iteración)

"""Interpretación: Dado que tenemos 7313 ejemplos en en conjunto de entrenamiento y hemos configurado un tamaño de lote de 256, habrá aproximadamente 7313 / 256 = 29   iteraciones en cada época.  

Entonces, durante el entrenamiento con 80 épocas, la red realizará un total de 80 * 29 = 2320 iteraciones a través de tus datos de entrenamiento.  
"""

historia = modelo.fit(
    x = x_tr_s,
    y = y_tr_s,
    batch_size = BATCH_SIZE,
    epochs = EPOCHS,
    validation_data = (x_vl_s, y_vl_s),
    verbose=2 #vemos como evoluciona el entrenamiento
)

"""Al completar las 80 iteraciones de entrenamiento podremos generar una gráfica de la variable historia para obtener las curvas del comportamiento de la pérdida con los sets de entrenamiento y validación."""

plt.plot(historia.history['loss'],label='RMSE_Train')
plt.plot(historia.history['val_loss'],label='RMSE_Val')
plt.xlabel('Iteracion')
plt.ylabel('RMSE')
plt.legend();

"""La pérdida se reduce progresivamente en ambos casos a medida que aumentan las iteraciones  
El nivel de pérdida en la iteración 80 es similar en ambos casos.  
No se observa Overfitting  
*Cómo le harían un fine tuning al modelo???*

**Desempeño del Modelo**

Ahora, verificaremos el desempeño del modelo usando el set de datos que hasta el momento no hemos presentado a la Red: el set de prueba.
"""

rmse_tr = modelo.evaluate(x=x_tr_s, y=y_tr_s, verbose=0)
rmse_vl = modelo.evaluate(x=x_vl_s, y=y_vl_s, verbose=0)
rmse_ts = modelo.evaluate(x=x_ts_s, y=y_ts_s, verbose=0)

print('Comparativo desempeños:')
print(f'  RMSE train:\t {rmse_tr:.3f}')
print(f'  RMSE val:\t {rmse_vl:.3f}')
print(f'  RMSE test:\t {rmse_ts:.3f}')

"""Los RMSEs obtenidos son comparables el modelo generaliza bastante bien (genera predicciones adecuadas sobre un set de datos que no había visto previamente)

**Predicciones (forecasting) con el modelo entrenado**
"""

def predecir(x, model, scaler):
    # Calcular predicción escalada en el rango de -1 a 1
    y_pred_s = model.predict(x,verbose=0)

    # Llevar la predicción a la escala original
    y_pred = scaler.inverse_transform(y_pred_s)

    return y_pred.flatten()

y_ts_pred = predecir(x_ts_s, modelo, scaler)

N = len(y_ts_pred)    # Número de predicciones (tamaño del set de prueba)
ndato = np.linspace(1,N,N)

# Cálculo de errores simples
errores = y_ts.flatten()-y_ts_pred
plt.plot(errores);

fig, ax = plt.subplots(figsize=(16,5))
ax.plot(y_ts_pred,label="pred")
ax.plot(y_ts.flatten(),label="test")
plt.legend();

"""Libros recomendados y fuente del ejercicio adaptado:

Deep Learning with Python, 2nd Edition (Final Release) (Francois Chollet  [Chollet, François])  
Machine Learning Mastery - Long-short-term-memory-networks-with-python  
**Fuente** para profundización, variantes del modelo y desarrollos: https://www.youtube.com/watch?v=R8MEPGn9sFI
"""